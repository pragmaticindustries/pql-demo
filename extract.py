import random
from typing import Any


class FieldType(object):

    def is_generated(self) -> bool:
        raise NotImplementedError

    def apply(self, current_state: dict) -> Any:
        raise NotImplementedError


class AutoGeneratedField(FieldType):

    def __init__(self) -> None:
        self.counter = 0

    def is_generated(self) -> bool:
        return True

    def apply(self, current_state: dict):
        self.counter += 1
        return self.counter

    def __str__(self) -> str:
        return f"AutoGenerated({self.counter + 1})"


class Parameter(FieldType):

    def __init__(self, field_name):
        self.field_name = field_name

    def is_generated(self) -> bool:
        return False

    def apply(self, current_state: dict):
        if self.field_name in current_state:
            return current_state.get(self.field_name)
        else:
            raise RuntimeError(f"No field {self.field_name} found!")

    def __str__(self) -> str:
        return f"-> {self.field_name}"


if __name__ == '__main__':
    """
    EntitÃ¤ten:
    * Cycle
    * MaterialEquipped
    * ToolEquipped
    
    Cycle: 
    id -> cycle_number
    
    MaterialEquipped:
    id -> Auto generated
    material_name -> material_name
    
    ToolEquipped:
    id -> Auto generated
    tool_name -> tool_name
    
    """
    def intiStates():
        material_id = 1
        tool_id = 1
        cycle_id = 1

        states = []

        random.seed(1)

        for t in range(0, 1000):
            if random.uniform(0.0, 100.0) < 1.0:
                material_id = (material_id + 1) % 3
            current_material = f"Material {material_id}"

            if random.uniform(0.0, 100.0) < 1.0:
                tool_id += 1
            current_tool = f"Tool {material_id}"

            if random.uniform(0.0, 100.0) < 10.0:
                cycle_id += 1
            current_cycle_number = cycle_id

            state = {
                "timestamp": t,
                "material_name": current_material,
                "material_type": current_material,
                "tool_name": current_tool,
                "cycle_number": cycle_id
            }

            # print(f"Aktueller Zustand: {state}")

            states.append(state)
        return  states

    states = intiStates()
    #print(states,flush=True)
    # states = [{'timestamp': 0, 'material_name': 'Material 1', 'tool_name': 'Tool 1', 'cycle_number': 1},
    #           {'timestamp': 1, 'material_name': 'Material 1', 'tool_name': 'Tool 1', 'cycle_number': 1},
    #           {'timestamp': 2, 'material_name': 'Material 1', 'tool_name': 'Tool 1', 'cycle_number': 2},
    #           {'timestamp': 3, 'material_name': 'Material 1', 'tool_name': 'Tool 1', 'cycle_number': 3},
    #           {'timestamp': 4, 'material_name': 'Material 1', 'tool_name': 'Tool 1', 'cycle_number': 4}]

    config: dict = {
        "Cycle": {
            "id": Parameter("cycle_number")
        },
        "ToolEquipped": {
            "id": AutoGeneratedField(),
            "tool_name": Parameter("tool_name")
        },
        "MaterialEquipped": {
            "id": AutoGeneratedField(),
            "material_name": Parameter("material_name"),
            "material_typ": Parameter("material_type")
        }
    }


    class StateProcessor(object):

        def __init__(self, config,element) -> None:
            super().__init__()
            self.config = config
            self.context = {}
            self.end_result = {}
            self.timestamps = {k: 0 for k in self.config.keys()}
            self.__init_context__(element)

        def __exctract_all_items__(self,entity,state):
            all_items:dict = {k: v.apply(state) for k, v in self.config.get(entity).items() if v.is_generated()}
            all_items.update(self.context[entity])
            all_items.update({"start":self.timestamps[entity],"end":state.get("timestamp")})
            return all_items

        def __init_context__(self,first_element_of_stream):
            for entity in self.config.keys():
                self.context[entity] = {k: v.apply(first_element_of_stream) for k, v in self.config.get(entity).items() if not v.is_generated()}
                self.end_result.update({f"{entity}":[]})

        def process_state(self, state, is_last = False):
            for entity in config.keys():
                current_context = {k: v.apply(state) for k, v in self.config.get(entity).items() if not v.is_generated()}
                if not is_last:
                    if self.context[entity] != current_context:
                        all_items = self.__exctract_all_items__(entity,state)
                        self.end_result[entity].append(all_items)
                        self.context[entity] = current_context
                        self.timestamps[entity] = state.get("timestamp")
                else:
                    all_items = self.__exctract_all_items__(entity, state)
                    self.end_result[entity].append(all_items)

        def get_result(self):
            return self.end_result


    processor = StateProcessor(config,states[0])
    for state in states:
        processor.process_state(state, state == states[-1])
    print(processor.get_result())

    # result_dict = {}
    # #
    # for k,v in config.get("ToolEquipped").items():
    #     v: FieldType
    #
    #     if v.is_generated():
    #         print(f"Is generated, skipping {k} for equality testing...")
    #
    #     res = v.apply(current_state)
    #
    #     result_dict.update({k: res})
    #
    # print(f"Result Dict: {result_dict}")
    #
    # for entity in config.keys():
    #     result_dict_2 = {k: v.apply(current_state) for k,v in config.get(entity).items() if not v.is_generated()}
    #
    #     print(f"Entity: {entity}")
    #     print(f"Result Dict 2: {result_dict_2}")

    #
    # context = {}
    # current_state = states[0]
    # end_result = {}
    # for entity in config.keys():
    #     context[entity] = {k: v.apply(current_state) for k, v in config.get(entity).items() if not v.is_generated()}
    #     end_result.update({f"{entity}":[]})
    #
    # timestamps = {k: 0 for k in config.keys()}
    # i: int = 0
    # for state in states:
    #     is_last = (i == len(states)-1)
    #     for entity in config.keys():
    #         current_context = {k: v.apply(state) for k, v in config.get(entity).items() if not v.is_generated()}
    #         if not is_last:
    #             if context[entity] != current_context:
    #                 all_items:dict = {k: v.apply(state) for k, v in config.get(entity).items() if v.is_generated()}
    #                     #print(context[entity])
    #                 all_items.update(context[entity])
    #                 all_items.update({"start":timestamps[entity],"end":state.get("timestamp")})
    #                 end_result[entity].append(all_items)
    #                 context[entity] = current_context
    #                 timestamps[entity] = state.get("timestamp")
    #         else:
    #             all_items:dict = {k: v.apply(state) for k, v in config.get(entity).items() if v.is_generated()}
    #             all_items.update(context[entity])
    #             all_items.update({"start":timestamps[entity],"end":state.get("timestamp")})
    #             end_result[entity].append(all_items)
    #     i+=1
    # print(end_result)
    # result = {
    #     "Cycle": [
    #         {"cycle_id": 1, "start": 0, "end": 10},
    #         {"cycle_id": 2, "start": 11, "end": 25},
    #         # ...
    #     ],
    #     "ToolEquipped": [
    #         # ...
    #     ],
    #     "MaterialEquipped": [
    #         {"id": 1, "material_name": "Material 1", "start": 0, "end": 43}
    #         # ...
    #     ]
    # }
    # tool_dict: dict = {'id': 11, 'tool_name': 'Tool 2', 'start': 835, 'end': 999}
    # material_dict: dict = {'id': 11, 'material_name': 'Material 2', 'material_typ': 'Material 2', 'start': 835, 'end': 999}
    #
    # assert end_result["Cycle"][1] == {'id': 2, 'start': 2, 'end': 6}
    # assert end_result["Cycle"][-1] == {'id': 114, 'start': 993, 'end': 999}
    # assert end_result["ToolEquipped"][-1] == tool_dict
    # assert end_result["MaterialEquipped"][-1] == material_dict
