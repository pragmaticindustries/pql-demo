import random
import uuid
from typing import Any


class FieldType(object):
    def is_generated(self) -> bool:
        raise NotImplementedError

    def is_foreignkey(self) -> bool:
        raise NotImplementedError

    def apply(self, current_state: dict) -> Any:
        raise NotImplementedError

    def reset(sef) -> Any:
        raise NotImplementedError

    def reset_all(self) -> Any:
        raise NotImplementedError


class AutoGeneratedField(FieldType):
    def __init__(self) -> None:
        self.counter = 0

    def is_generated(self) -> bool:
        return True

    def is_foreignkey(self) -> bool:
        return False

    def apply(self, current_state: dict):
        self.counter += 1
        return self.counter

    def reset(self):
        self.counter = 0

    def reset_all(self):
        self.counter = 0

    def __str__(self) -> str:
        return f"AutoGenerated({self.counter + 1})"


class AutoGeneratedUUID(FieldType):
    def __init__(self) -> None:
        self.uuid = 0

    def is_generated(self) -> bool:
        return True

    def is_foreignkey(self) -> bool:
        return False

    def apply(self, current_state: dict):
        self.uuid = str(uuid.uuid4())
        return self.uuid

    def reset(self):
        self.uuid = 0

    def reset_all(self):
        self.uuid = 0

    def __str__(self) -> str:
        return f"AutoGenerated({self.uuid})"


class ReferenceFieldType(FieldType):
    def __init__(self, config_entity: str, entity_id: str) -> None:
        self.config_entity: str = config_entity
        self.relation_id: str = entity_id

    def is_foreignkey(self) -> bool:
        return True

    def apply(self, parent_entity: str, state: str, end_result: dict, key) -> Any:
        raise NotImplementedError

    def reset(self):
        raise NotImplementedError

    def reset_all(self):
        raise NotImplementedError


class AutoGeneratedOneToOne(ReferenceFieldType):
    def __init__(self, config_entity: str, entity_id: str) -> None:
        self.config_entity = config_entity
        self.relation_id = entity_id
        self.change_index = 0
        self.constraints = {}

    def is_generated(self) -> bool:
        return True

    def is_foreignkey(self) -> bool:
        return True

    def apply(self, parent_entity: str, state: str, end_result: dict, key):
        """In this Method the Rleation ist set.
        First of al we loop through the entire Config
        Then we range through the loop where the last change therefore the last Element is
        Then we look up it there are The same dicts in the Constrains
        The Paramter the partent_entity ist the Entity which saves the Foreignkey
        The State is the actual array from the Stream
        End_Result is the sorted dict
        and key ist the Name of the Relation from the Config"""
        if state == self.config_entity:
            end_change = len(end_result[parent_entity])
            for i in range(self.change_index, end_change):
                if not any(
                    {
                        "id": end_result[parent_entity][i].get("id"),
                        self.config_entity: end_result[self.config_entity][-1].get(
                            self.relation_id
                        ),
                    }
                    in self.constraints
                ):
                    end_result[parent_entity][i].update(
                        {
                            f"{key}": end_result[self.config_entity][-1].get(
                                self.relation_id
                            )
                        }
                    )
                    self.constraints.append(
                        {
                            "id": end_result[parent_entity][i].get("id"),
                            self.config_entity: end_result[self.config_entity][-1].get(
                                self.relation_id
                            ),
                        }
                    )
                else:
                    raise RuntimeError(
                        f"There is allready an existing Entry for {'id':end_result[parent_entity][i].get('id'),self.config_entity:end_result[self.config_entity][-1].get(self.relation_id)}"
                    )
            self.change_index = end_change

    def reset(self):
        self.change_index = 0

    def reset_all(self):
        self.reset()
        self.constraints = {}
        self.relation_id = None
        self.config_entity = None

    def __str__(self) -> str:
        return f"AutoGenerated({self.config_entity,self.relation_id})"


class AutoGeneratedOneToMany(ReferenceFieldType):
    def __init__(self, config_entity: str, entity_id: str) -> None:
        self.config_entity = config_entity
        self.relation_id = entity_id
        self.change_index = 0
        self.constraints = []

    def is_generated(self) -> bool:
        return True

    def is_foreignkey(self) -> bool:
        return True

    def apply(self, parent_entity: str, state: str, end_result: dict, key):
        """In this Method the Rleation ist set.
        First of al we loop through the entire Config
        Then we range through the loop where the last change therefore the last Element is
        Then we look up it there are The same dicts in the Constrains
        The Paramter the partent_entity ist the Entity which saves the Foreignkey
        The State is the actual array from the Stream
        End_Result is the sorted dict
        and key ist the Name of the Relation from the Config"""
        if state == self.config_entity:
            end_change = len(end_result[parent_entity])
            for i in range(self.change_index, end_change):
                if not any(
                    d.get("id", None) == end_result[parent_entity][i].get("id")
                    for d in self.constraints
                ):
                    end_result[parent_entity][i].update(
                        {
                            f"{key}": end_result[self.config_entity][-1].get(
                                self.relation_id
                            )
                        }
                    )
                    self.constraints.append(
                        {
                            "id": end_result[parent_entity][i].get("id"),
                            self.config_entity: end_result[self.config_entity][-1].get(
                                self.relation_id
                            ),
                        }
                    )
                else:
                    raise RuntimeError(
                        f"There is allready an existing Entry for {end_result[self.config_entity][-1].get(self.relation_id)}"
                    )
            self.change_index = end_change

    def reset(self):
        self.change_index = 0
        self.constraints = []

    def reset_all(self):
        self.reset()
        self.relation_id = None
        self.config_entity = None

    def __str__(self) -> str:
        return f"AutoGenerated({self.config_entity,self.relation_id})"


class AutoGeneratedManyToOne(ReferenceFieldType):
    def __init__(self, config_entity: str, entity_id: str) -> None:
        self.config_entity = config_entity
        self.relation_id = entity_id
        self.change_index = 0
        self.constraints = []

    def is_generated(self) -> bool:
        return True

    def is_foreignkey(self) -> bool:
        return True

    def apply(self, parent_entity: str, state: str, end_result: dict, key):
        """In this Method the Rleation ist set.
        First of al we loop through the entire Config
        Then we range through the loop where the last change therefore the last Element is
        Then we look up it there are The same dicts in the Constrains
        The Paramter the partent_entity ist the Entity which saves the Foreignkey
        The State is the actual array from the Stream
        End_Result is the sorted dict
        and key ist the Name of the Relation from the Config"""
        if state == self.config_entity:
            end_change = len(end_result[parent_entity])
            for i in range(self.change_index, end_change):
                if not any(
                    d.get("id", None) == end_result[parent_entity][i].get("id")
                    for d in self.constraints
                ):
                    end_result[parent_entity][i].update(
                        {
                            f"{key}": end_result[self.config_entity][-1].get(
                                self.relation_id
                            )
                        }
                    )
                    self.constraints.append(
                        {
                            "id": end_result[parent_entity][i].get("id"),
                            self.config_entity: end_result[self.config_entity][-1].get(
                                self.relation_id
                            ),
                        }
                    )
                else:
                    raise RuntimeError(
                        f"There is allready an existing Entry for {end_result[parent_entity][i].get('id')}"
                    )
            self.change_index = end_change

    def reset(self):
        self.change_index = 0
        self.constraints = []

    def reset_all(self):
        self.reset()
        self.config_entity = None
        self.relation_id = None

    def __str__(self) -> str:
        return f"AutoGenerated({self.config_entity,self.relation_id})"


class AutoGeneratedManyToMany(FieldType):
    def __init__(self) -> None:
        self.uuid = 0

    def is_generated(self) -> bool:
        return True

    def apply(self, current_state: dict):
        self.uuid = str(uuid.uuid4())
        return self.uuid

    def __str__(self) -> str:
        return f"AutoGenerated({self.uuid})"


class Parameter(FieldType):
    def __init__(self, field_name):
        self.field_name = field_name

    def is_generated(self) -> bool:
        return False

    def is_foreignkey(self) -> bool:
        return False

    def apply(self, current_state: dict):
        if self.field_name in current_state:
            return current_state.get(self.field_name)
        else:
            raise RuntimeError(f"No field {self.field_name} found!")

    def reset(self):
        self.change_index = None

    def reset_all(self):
        self.reset()

    def __str__(self) -> str:
        return f"-> {self.field_name}"


class StateProcessor(object):
    def __init__(self, config, element, new_config) -> None:
        super().__init__()
        self.config = config
        self.context = {}
        self.end_result = {}
        if not new_config:
            self.reset_fk_constraints_and_autogen_fields()
        self.__init_context__(element)

    def __exctract_all_items__(self, entity, state):
        all_items: dict = {
            k: v.apply(state)
            for k, v in self.config.get(entity).items()
            if not v.is_foreignkey()
        }
        all_items.update(
            {"start": state.get("timestamp"), "end": state.get("timestamp")}
        )
        return all_items

    def __extract_all_not_autogen_items__(self, entity, state):
        all_items: dict = {
            k: v.apply(state)
            for k, v in self.config.get(entity).items()
            if not v.is_generated() and not v.is_foreignkey()
        }
        all_items.update(
            {"start": state.get("timestamp"), "end": state.get("timestamp")}
        )
        return all_items

    def reset_foreignkeys_and_constraints(self):
        """Needed for Tests if there are two ore more tests,
        the ID fk and constrians should be remove otherway there will be Errors"""
        for entity in self.config.keys():
            for k, v in self.config.get(entity).items():
                if v.is_generated() and v.is_foreignkey():
                    element: ReferenceFieldType = v
                    element.reset()

    def reset_autogen_fields(self):
        """Needed if there is one config for many Tests"""
        for entity in self.config.keys():
            for k, v in self.config.get(entity).items():
                if v.is_generated() and not v.is_foreignkey():
                    element: FieldType = v
                    element.reset()

    def reset_fk_constraints_and_autogen_fields(self):
        """Same thing needed for tests or if after nay brake down the Ids and so one shoulb be 0"""
        for entity in self.config.keys():
            for k, v in self.config.get(entity).items():
                if v.is_generated():
                    element: FieldType = v
                    element.reset()

    def __init_context__(self, first_element_of_stream):
        """init Method for the Result dict
        The dict gets its Entitys here and get empty Arrays for appending each entry in the array later
        The first Element of the Stream will be append here, so we check if the acctual element is diffrent form this init  one"""
        for entity in self.config.keys():
            x = {
                k: v.apply(first_element_of_stream)
                for k, v in self.config.get(entity).items()
                if not v.is_foreignkey()
            }
            x.update(
                {
                    "start": first_element_of_stream.get("timestamp"),
                    "end": first_element_of_stream.get("timestamp"),
                }
            )
            self.context[entity] = {
                k: v.apply(first_element_of_stream)
                for k, v in self.config.get(entity).items()
                if not v.is_generated() and not v.is_foreignkey()
            }
            self.end_result.update({f"{entity}": []})
            self.end_result[entity].append(x)
        self.process_foreingkeys(entity)

    def process_state(self, state):
        for entity in self.config.keys():
            current_context = {
                k: v.apply(state)
                for k, v in self.config.get(entity).items()
                if not v.is_generated() and not v.is_foreignkey()
            }
            if self.context[entity] != current_context:
                all_items = self.__exctract_all_items__(entity, state)
                self.end_result[entity].append(all_items)
            self.end_result[entity][-1]["end"] = state.get("timestamp")
            self.context[entity] = current_context
            self.process_foreingkeys(entity)

    def process_foreingkeys(self, state):
        for entity in self.config.keys():
            {
                k: v.apply(entity, state, self.end_result, k)
                for k, v in self.config.get(entity).items()
                if v.is_generated() and v.is_foreignkey()
            }

    def get_result(self):
        return self.end_result


if __name__ == "__main__":
    """
    Entititys:
    * Cycle
    * MaterialEquipped
    * ToolEquipped

    Cycle:
    id -> cycle_number

    MaterialEquipped:
    id -> Auto generated
    material_name -> material_name

    ToolEquipped:
    id -> Auto generated
    tool_name -> tool_name

    """

    def intiStates():
        material_id = 1
        tool_id = 1
        cycle_id = 1

        states = []

        random.seed(1)

        for t in range(0, 1000):
            if random.uniform(0.0, 100.0) < 1.0:
                material_id = (material_id + 1) % 3
            current_material = f"Material {material_id}"

            if random.uniform(0.0, 100.0) < 1.0:
                tool_id += 1
            current_tool = f"Tool {material_id}"

            if random.uniform(0.0, 100.0) < 10.0:
                cycle_id += 1
            current_cycle_number = cycle_id

            state = {
                "timestamp": t,
                "material_name": current_material,
                "material_type": current_material,
                "tool_name": current_tool,
                "cycle_number": cycle_id,
            }

            # print(f"Aktueller Zustand: {state}")

            states.append(state)
        return states

    states = intiStates()
    # print(states,flush=True)
    # states = [{'timestamp': 0, 'material_name': 'Material 1','material_type': 'Material 1','tool_name': 'Tool 1', 'cycle_number': 1},
    #           {'timestamp': 1, 'material_name': 'Material 1', 'material_type': 'Material 1','tool_name': 'Tool 1', 'cycle_number': 1},
    #           {'timestamp': 2, 'material_name': 'Material 2', 'material_type': 'Material 2','tool_name': 'Tool 1', 'cycle_number': 2},
    #           {'timestamp': 3, 'material_name': 'Material 2', 'material_type': 'Material 2','tool_name': 'Tool 1', 'cycle_number': 3},
    #           {'timestamp': 4, 'material_name': 'Material 2','material_type': 'Material 2', 'tool_name': 'Tool 1', 'cycle_number': 4}]

    # Parameter: state -> scalar
    # AutoGenerated: state -> scalar

    # Reference:
    # AutoGeneratedOneToOne: state, history -> scalar

    # Cycle | Material
    # 1     | Material 1
    # 1     | Material 2

    config: dict = {
        "Cycle": {
            "id": Parameter("cycle_number"),
            "material_equipped": AutoGeneratedManyToOne("MaterialEquipped", "id"),
        },
        # CREATE TABLE Cycle (id BIGINT SERIAL PRIMARY KEY, material_equipped BIGINT NON NULL)
        # CREATE FOREIGN KEY ...
        "ToolEquipped": {
            "id": AutoGeneratedField(),
            "uuid": AutoGeneratedUUID(),
            "tool_name": Parameter("tool_name"),
        },
        "MaterialEquipped": {
            "id": AutoGeneratedField(),
            "uuid": AutoGeneratedUUID(),
            "material_name": Parameter("material_name"),
            "material_typ": Parameter("material_type"),
        },
    }

    processor = StateProcessor(config, states[0], False)
    for state in states:
        processor.process_state(state)
    end_result = processor.get_result()

    # result_dict = {}
    # #
    # for k,v in config.get("ToolEquipped").items():
    #     v: FieldType
    #
    #     if v.is_generated():
    #         print(f"Is generated, skipping {k} for equality testing...")
    #
    #     res = v.apply(current_state)
    #
    #     result_dict.update({k: res})
    #
    # print(f"Result Dict: {result_dict}")
    #
    # for entity in config.keys():
    #     result_dict_2 = {k: v.apply(current_state) for k,v in config.get(entity).items() if not v.is_generated()}
    #
    #     print(f"Entity: {entity}")
    #     print(f"Result Dict 2: {result_dict_2}")

    result = {
        "Cycle": [
            {"cycle_id": 1, "start": 0, "end": 10},
            {"cycle_id": 2, "start": 11, "end": 25},
            # ...
        ],
        "ToolEquipped": [
            # ...
        ],
        "MaterialEquipped": [
            {"id": 1, "material_name": "Material 1", "start": 0, "end": 43}
            # ...
        ],
    }
    tool_dict: dict = {"id": 11, "tool_name": "Tool 2", "start": 835, "end": 999}
    material_dict: dict = {
        "id": 11,
        "material_name": "Material 2",
        "material_typ": "Material 2",
        "start": 835,
        "end": 999,
    }

    assert end_result["Cycle"][0] == {
        "id": 1,
        "start": 0,
        "end": 1,
        "material_equipped": 1,
    }
    assert end_result["Cycle"][-1] == {
        "id": 114,
        "start": 993,
        "end": 999,
        "material_equipped": 11,
    }
    end_result["ToolEquipped"][-1].pop("uuid")
    assert end_result["ToolEquipped"][-1] == tool_dict
    end_result["MaterialEquipped"][-1].pop("uuid")
    assert end_result["MaterialEquipped"][-1] == material_dict
